// This #include statement was automatically added by the Particle IDE.
#include "TM1637Display/TM1637Display.h"

// This #include statement was automatically added by the Particle IDE.
#include "HttpClient/HttpClient.h"

#include <stdio.h>
#include <math.h>


#define BUTTONPIN D6
#define CLK D4
#define DIO D5
#define waterCapacity A0
byte waterCapacityInterrupt = A0;

void dispWaterConsumed(unsigned int num);

TM1637Display display(CLK,DIO);



byte coldSensorInterrupt = D2;  // 1 = digital pin 3
byte coldSensorPin       = D2;

// The hall-effect flow sensor outputs approximately 42 pulses per second per
// litre/minute of flow.
float calibrationFactor = 42;

//Calibrates the rotary angle sensor to Milliletters
float rotationRotaToMilliLetres = 2.44;

volatile byte coldPulseCount,capacityChange;

float hotFlowRate, coldFlowRate;
unsigned int hotFlowMilliLitres, coldFlowMilliLitres;
unsigned long hotTotalMilliLitres, coldTotalMilliLitres;
int milliLitresCarried, waterPercent, milliLitresConsumed, capacityChangeINT,  milliLitresSaved;
float milliLitresCarriedDec, waterPercentDec, milliLitresConsumedDec;
boolean hotFlag, coldFlag;

unsigned long oldTime, oldTimeMaster, showTime;
int addr = 2; //address of EEPROM to use to store water consumed
String resettest="reset";
char history[3000];

bool publishGulps = true;

//Deffines my LED Constant
    const uint8_t SEG_90[] = {
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C   // ||
	};
	

    const uint8_t SEG_80[] = {
	SEG_B | SEG_C,                  // |
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C   // ||
	};
	

    const uint8_t SEG_70[] = {
	SEG_G,
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C   // ||
	};

    const uint8_t SEG_60[] = {
	SEG_G,
	SEG_B | SEG_C,                  // |
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C   // ||
	};
	
    const uint8_t SEG_50[] = {
	SEG_G,
	SEG_G,
	SEG_E | SEG_F | SEG_B | SEG_C,  // ||
	SEG_E | SEG_F | SEG_B | SEG_C  // ||
	};
	
	const uint8_t SEG_40[] = {
	SEG_G,
	SEG_G,
	SEG_B | SEG_C,                 // |
	SEG_E | SEG_F | SEG_B | SEG_C  // ||	
	};

	const uint8_t SEG_30[] = {
    SEG_G,
    SEG_G,
	SEG_G,
	SEG_E | SEG_F | SEG_B | SEG_C  // ||
	};
	
    const uint8_t SEG_20[] = {
    SEG_G,
    SEG_G,
	SEG_G,
    SEG_B | SEG_C                 // |
	};
	
    const uint8_t SEG_LO[] = {
	SEG_D | SEG_E | SEG_F,                           // L
	SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F,   // O
	};
	
	const uint8_t SEG_OUT[] = {
	SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F,    // O
    SEG_B | SEG_C | SEG_D | SEG_E | SEG_F,           // U
	SEG_D | SEG_E | SEG_F | SEG_G,                   // t
	};

void setup() {
    Spark.publish("notifyr/announce", "Gouldies Photon is up and running! HydraFlow - are you parched?");
  // Initialize a serial connection for reporting values to the host
  Serial.begin(38400);

  //Initialise the digital display
 // tm1637.set();
  //tm1637.init();
  //Particle.function('test',resetCounter);
  //Set the Pin For the reset button
  pinMode(BUTTONPIN, INPUT);
  display.setBrightness(0x0f);
  //  pinMode(hotSensorPin, INPUT);
//  digitalWrite(hotSensorPin, HIGH);
  pinMode(coldSensorPin, INPUT);
  digitalWrite(coldSensorPin, HIGH);

  coldFlag = false;
  coldPulseCount, capacityChange = 0;
  capacityChangeINT = 0;
  coldFlowRate = 0.0;
  coldFlowMilliLitres = 0;
  coldTotalMilliLitres = 0;
  milliLitresConsumed =0;
  milliLitresSaved = 0;
  milliLitresCarried = 0;
  oldTime = 0;
  oldTimeMaster = 0;
  waterPercent = 100;
  //strcpy (history,"{\"drunk\": \"100\", \"time\": \"4\"}");
  
  int flow = 100;
  int histtime = 5;
  char flowHistory[3000];
  sprintf(flowHistory, "{\"drunk\":%d,\"time\":%d}", flow, histtime); 
  strcpy (history, flowHistory);    

  dispWaterConsumed(milliLitresConsumed); //Display Water Consumed on Display
  milliLitresCarried = analogRead(waterCapacity)*rotationRotaToMilliLetres;
  
  int consumedEEprom = 0;
  EEPROM.get(addr, consumedEEprom);
    milliLitresConsumed = consumedEEprom;
    
  Particle.variable("History", history, STRING);
  Spark.variable("Carried", &milliLitresCarried, INT);
  Spark.variable("TotalDrunk", &milliLitresConsumed, INT);
  Spark.variable("Percent", &waterPercent, INT);

  
//  Spark.variable("capacityChange", &capacityChangeINT, INT);

 Spark.function("resetMlDrunk",resetCounter);

  // The Hall-effect sensor is connected to pin 2 which uses interrupt 0.
  // Configured to trigger on a FALLING state change (transition from HIGH
  // state to LOW state)
//  attachInterrupt(hotSensorInterrupt, hotPulseCounter, FALLING);
  attachInterrupt(coldSensorInterrupt, coldPulseCounter, FALLING);
//  attachInterrupt(waterCapacityInterrupt, waterCapacityChange, CHANGE);
}

/**
 * Main program loop
 */
void loop() {

     if((digitalRead(BUTTONPIN) == 1) && (milliLitresCarried==0)){
         resetCounter(resettest);

      //  Spark.publish("Liters_Consumed_reset", String(coldFlowRate));
     }
     

     milliLitresCarriedDec = analogRead(waterCapacity)*rotationRotaToMilliLetres; //readed the value for amount of water carried.

     milliLitresCarried = floor((milliLitresCarriedDec)/10)*10;

    milliLitresCarriedDec = milliLitresCarried;

    milliLitresConsumedDec = milliLitresConsumed;

    waterPercentDec = waterPercent;

    waterPercentDec = ((milliLitresCarriedDec - milliLitresConsumedDec) / milliLitresCarriedDec)*100 ; //Create percentage for LED display

    waterPercent = round(waterPercentDec); //Convert Float to Decimal

     displayLevels(digitalRead(BUTTONPIN));


//    if(capacityChange < 0){
//        capacityChange = 0;
//    }

 //do stuff that needs to be done every second
 oneSecTimer();

// fiveSecTimer();
 //do stuff that needs to be done every 10 seconds
 tenSecTimer();


    showTime = millis() - oldTime;
  if((showTime) > 1000) {

    // Removign the interupt listner so we can calcualte the value.
 //   detachInterrupt(hotSensorInterrupt);
    detachInterrupt(coldSensorInterrupt);
//Convert pulse count to letres by using time
    coldFlowRate = ((1000.0/(showTime)) * coldPulseCount) / calibrationFactor;

//alter flow rate because it will continuously output a low decimal number and we don't want it tracking this.
    if(coldFlowRate < 0.14){
        coldFlowRate = 0;
    }
    
    coldFlowMilliLitres = (coldFlowRate / 60) * 1000;

    coldTotalMilliLitres += coldFlowMilliLitres;

// check to see if water has been drunk and the flow has stopped, if so set the flag to measure water
    if(coldTotalMilliLitres > 0 && coldFlowRate == 0) {
      coldFlag = true;

    }
    oldTime = millis();
  //  unsigned int frac;


    // if we finished mesuring cold water, lets save the data
    if(coldFlag) {
        milliLitresConsumed += coldTotalMilliLitres;
        milliLitresSaved = coldTotalMilliLitres;
        publishGulps = true;
        coldTotalMilliLitres = 0;
        coldFlag = false;
    }
    //update EEPROM with Cunsumed water for persistance

    EEPROM.update(addr,milliLitresConsumed);
    int value=0;
    EEPROM.get(addr, value);
    // Print the flow rate for this second in litres / minute

    // Determine the fractional part. The 10 multiplier gives us 1 decimal place.
  //  frac = (coldFlowRate - int(coldFlowRate)) * 10;

  //reset cold pulse count to capture next set of Pulses
    coldPulseCount = 0;


 //   Serial.print("Just Put Consumed to EEPROM value was: ");
 //   Serial.print(int(value));  // Print the integer part of the variable
 //    Serial.print(".");

    // Reataching the interupt listner to the pins

    attachInterrupt(coldSensorInterrupt, coldPulseCounter, FALLING);
    
    //update EEPROM with Cunsumed water for persistance

  //  EEPROM.update(addr,milliLitresConsumed);
  //  int value=0;
  //  EEPROM.get(addr, value);
    //Publish amount drunk in gulps - period if a drink has been taken
    if (publishGulps){
            publishGulps = false;
            Spark.publish("librato_Gulps", String(milliLitresSaved), 60, PRIVATE);
            milliLitresSaved = 0;

    }

  }

}


//void hotPulseCounter() {
//  hotPulseCount++;
//}
int resetCounter(String resetvalue){
    Serial.print("  reset...............................................: ");             // Output separator
    Serial.print(resetvalue);
    Serial.println("reset......................................................");
    Spark.publish("reset",String(resetvalue));
      if (resetvalue=="reset"){
    milliLitresConsumed = 0;
    waterPercent = 100;
    EEPROM.put(addr,milliLitresConsumed);
//    dispWaterConsumed(milliLitresConsumed);
    return 0;
      }
}

void displayLevels(int num){
  if (num==0){

   //   Spark.publish("waterPercent", String(waterPercent));
         if((millis() - oldTimeMaster) > 5000){

            waterLevel(waterPercent);

         }
            else {
              dispWaterConsumed(milliLitresConsumed);  

            }
    }
    else {

        dispWaterCapacity(milliLitresCarried);
    } 

}



void coldPulseCounter() {
  coldPulseCount++;

}


void dispWaterConsumed(unsigned int num){

    display.showNumberDec(num);
}

void dispWaterCapacity(unsigned int num){
    display.showNumberDec(num);

}

void waterCapacityChange(){
    capacityChange = capacityChange + 100 ;

}


void waterLevel(int waterPercentage){

    if(waterPercentage <= 100 && waterPercentage >= 81 ){
        display.setSegments(SEG_90);

//       Spark.publish("hydraPack/90_%_Water", String(waterPercentage));
    }
    if(waterPercentage <= 80 && waterPercentage >= 71 ){
        display.setSegments(SEG_80);

//       Spark.publish("hydraPack/80_%_Water", String(waterPercentage));
    }
    if(waterPercentage <= 70 && waterPercentage >= 61 ){
        display.setSegments(SEG_70);

//       Spark.publish("hydraPack/70_%_Water", String(waterPercentage));
    }
    if(waterPercentage <= 60 && waterPercentage >= 51){
        display.setSegments(SEG_60);

//       Spark.publish("hydraPack/60_%_Water", String(waterPercentage));
    }
    if(waterPercentage <= 50 && waterPercentage >= 41 ){
        display.setSegments(SEG_50);

//       Spark.publish("hydraPack/50_%_Water", String(waterPercentage));
    }
    if(waterPercentage <= 40 && waterPercentage >= 31 ){
        display.setSegments(SEG_40);

//       Spark.publish("hydraPack/40_%_Water", String(waterPercentage));
    }
    if(waterPercentage <= 30 && waterPercentage >= 21 ){
        display.setSegments(SEG_30);

//       Spark.publish("hydraPack/30_%_Water", String(waterPercentage));
    }
    if(waterPercentage <= 20 && waterPercentage >= 11 ){
        display.setSegments(SEG_20);

//       Spark.publish("hydraPack/20_%_Water", String(waterPercentage));
    }
    if(waterPercentage <= 10 && waterPercentage > 0 ){
        display.setSegments(SEG_LO);

//       Spark.publish("hydraPack/LowOnWater", String(waterPercentage));
    }    // Spark.publish("flowrate", String(coldFlowRate));
    if(waterPercentage <= 0){
        display.setSegments(SEG_OUT);

//       Spark.publish("hydraPack/OutOfWater", String(waterPercentage));
    }
}

void oneSecTimer(){
 if((millis() - oldTime) >1000){
        //Spark.publish("flowrate", String(coldFlowRate));
         detachInterrupt(waterCapacityInterrupt);

         capacityChangeINT = capacityChange;

         if ( capacityChange > 0){  

//               dispWaterCapacity(milliLitresCarried);
               capacityChange=0;

             }
      attachInterrupt(waterCapacityInterrupt, waterCapacityChange, CHANGE); 

 }
}

void fiveSecTimer(){
             if((millis() - oldTimeMaster) > 5000){
        // Spark.publish("capacityChange", String(capacityChange)); //debug for CapacityChange
         dispWaterConsumed(milliLitresConsumed); //Display Water Consumed on Display //need to look at this a fix
         }
}

void tenSecTimer(){
         if((millis() - oldTimeMaster) > 10000) {
            Serial.println("still alive");
            EEPROM.update(addr,milliLitresConsumed);
            
            int value=0;

            EEPROM.get(addr, value);
            Serial.println(value);
  //          Serial.print("Just Put Consumed to EEPROM value was: ");
//            Serial.print(int(value));  // Print the integer part of the variable
 //           Serial.print(".");
            
//         milliLitresCarriedDec = milliLitresCarried;
//         milliLitresConsumedDec = milliLitresConsumed;
//         waterPercentDec = waterPercent;
 //        waterPercentDec = ((milliLitresCarriedDec - milliLitresConsumedDec) / milliLitresCarriedDec)*100 ;
//        waterPercent = round(waterPercentDec); //Convert Float to Decimal
              //Publish the total amount consumed, millilitres gulped, and amount of water carried
     //   Spark.publish("flowrate", String(coldFlowRate));
     //   Spark.publish("pulse count", String(coldPulseCount));
     //   Spark.publish("Time flow", String(showTime));
     //   Spark.publish("hydraPack/waterPercentageLeft", String(waterPercent));

//send webhook to liberato to track data
        Spark.publish("librato_TotalDrunk", String(milliLitresConsumed), 60, PRIVATE);

        Spark.publish("librato_Water_Carried", String(milliLitresCarried), 60, PRIVATE);

        Spark.publish("hydraFlow/MilliLitresConsumed", String(milliLitresConsumed));

        Spark.publish("hydraFlow/Percent Remaining", String(waterPercent));

    //    Spark.publish("TotalMillileters", String(coldTotalMilliLitres));
        Spark.publish("hydraFlow/WaterCapacity", String(milliLitresCarried));

   //     Spark.publish("flowrate", String(coldFlowRate));


     //   waterLow(waterPercent);
        oldTimeMaster = millis();


      }
}